/* 
** Universidade Federal de Sao Carlos
** Departamento de Computacao
** ProgramaÃ§Ã£o Paralela e DistribuÃ­da
** Prof. Helio Crestana Guardia
*/
/*
** Programa : tratamento de sinais (signals).
** Comando: 
** Objetivo: instalar rotina de tratamento e verificar o comportamento
**
**    Testar com <ctrl>c e <ctrl>z !!!
**    Para ver as threads: ps -L, -T, -m, m, H
**    Para ver tratamento de sinais nas threads: ps Hs
**    Observar que não há diferença entre instalar o tratamento antes
**    ou depois da criação das threads, na main thread ou em qualquer outra
*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <pthread.h>
#include <errno.h>
#include <string.h>

#define TTL 10
#define N_THREADS 5
#define LEN 128


// int pthread_kill(pthread_t thread, int sig);

// int pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);

// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);

/*
	int pthread_sigmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);

	int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);

The pthread_sigmask() function shall examine or change (or both) the calling thread's signal
mask, regardless of the number of threads in the process. The function shall  be  equivalent
to  sigprocmask(),  without  the restriction that the call be made in a single-threaded pro-
cess.

In a single-threaded process, the sigprocmask() function shall examine or change  (or  both)
the signal mask of the calling thread.

If  the  argument  set  is  not  a null pointer, it points to a set of signals to be used to
change the currently blocked set.

The argument how indicates the way in which the set is changed, and  the  application  shall
ensure it consists of one of the following values:

SIG_BLOCK
The resulting set shall be the union of the current set and the signal set pointed to by set.

SIG_SETMASK
The resulting set shall be the signal set pointed to by set.

SIG_UNBLOCK
The resulting set shall be the intersection of the current set and the complement  of
the signal set pointed to by set.

If  the  argument oset is not a null pointer, the previous mask shall be stored in the loca-
tion pointed to by oset.  If set is a null pointer, the value of the  argument  how  is  not
significant  and  the  processâ signal mask shall be unchanged; thus the call can be used to
enquire about currently blocked signals.

If there are any pending unblocked signals after the call to sigprocmask(), at least one  of
those signals shall be delivered before the call to sigprocmask() returns.

It  is  not possible to block those signals which cannot be ignored.  This shall be enforced
by the system without causing an error to be indicated.

If any of the SIGFPE, SIGILL, SIGSEGV, or  SIGBUS  signals  are  generated  while  they  are
blocked,  the  result  is undefined, unless the signal was generated by the kill() function,
the sigqueue() function, or the raise() function.

If sigprocmask() fails, the thread's signal mask shall not be changed.

The use of the sigprocmask() function is unspecified in a multi-threaded process.

RETURN VALUE
Upon successful completion pthread_sigmask() shall return 0; otherwise, it shall return  the
corresponding error number.
*/

/*
	int sigemptyset(sigset_t *set);
	int sigfillset(sigset_t *set);
	int sigaddset(sigset_t *set, int signum);
	int sigdelset(sigset_t *set, int signum);
	int sigismember(const sigset_t *set, int signum);

	sigemptyset() initializes the signal set given by set to empty, with
		all signals excluded from the set.
	sigfillset() initializes set to full, including all signals.
	sigaddset() and sigdelset() add and delete respectively  signal  signum from set.
	sigismember() tests whether signum is a member of set.
*/

void 
sig_hand(int signo)
{
	printf("Thread %lu received %d\n",(unsigned long)pthread_self(),signo);
}


void *
thread(void * arg)
{
	int i, result;
	sigset_t sinais;
	char err_msg[LEN];

	printf("Thread %d (%lu)\n",(int)arg,(long)pthread_self());

	// Bloqueia, ou não, o rececimento de sinais
	if((int)arg%2) {

		// int sigemptyset(sigset_t *set);
		if(sigemptyset(&sinais)==-1) {
			strerror_r(errno,err_msg,LEN);
			printf("%d: erro em sigemptyset: %s\n",(int)arg,err_msg); 
			pthread_exit(NULL);
		}
		// int sigaddset(sigset_t *set, int signum);
		if(sigaddset(&sinais,SIGINT)==-1) {
			strerror_r(errno,err_msg,LEN);
			printf("%d: erro em sigaddset: %s\n",(int)arg,err_msg); 
			pthread_exit(NULL);
		}
		// int pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);
		if((result=pthread_sigmask(SIG_BLOCK, &sinais, 0)==-1)) {
			strerror_r(result,err_msg,LEN);
			printf("%d: erro em pthread_sigmask: %s\n",(int)arg,err_msg); 
			pthread_exit(NULL);
		}
		printf("Thread %d bloqueou SIGINT\n",(int)arg);
	}

	for(i=0;i<TTL;i++) {
		sleep(1);

		// sigpending()  returns the set of signals that are pending for delivery to the
		// calling thread (i.e., the signals which have been raised while blocked).  The
		// mask of pending signals is returned in set.

		// int sigpending(sigset_t *set);
		if(sigpending(&sinais)==-1) {
			strerror_r(errno,err_msg,LEN);
			printf("%d: erro em sigpending: %s\n",(int)arg,err_msg); 
			pthread_exit(NULL);
		}
		for (i=1;i<32;i++) {
			// int sigismember(const sigset_t *set, int signum);
			if(sigismember(&sinais,i))
				printf("%d: sinal %d pendente.\n",(int)arg,i);
		}	
	}
	pthread_exit(NULL);
} 


int 
main(int argc, char **argv)
{
	int i, ind, result;
	pthread_t th_vec[N_THREADS];
	char err_msg[LEN];
	struct sigaction ssa;

	srandom(getpid());

	// Instala rotina de tratamento SIGINT
	// Tratamento deve valer para todas as threads
	ssa.sa_handler = sig_hand;
	sigemptyset(&ssa.sa_mask);
	ssa.sa_flags = SA_RESTART;

	if(sigaction(SIGINT, &ssa, NULL) == -1) {
		strerror_r(errno,err_msg,LEN);
		printf("Erro na captura do signal: %s\n",err_msg);
	}

	// Cria threads
	for(i=0;i<N_THREADS;i++) {
		if((result=pthread_create(&th_vec[i], NULL, thread,(void *)i))) {
			strerror_r(result,err_msg,LEN);
			printf("Erro em ptread_create (%d): %s\n",i,err_msg);
			exit(0);
		}
	}

	printf("Main thread: %lu\n",pthread_self());

	for(i=0;i<TTL;i++) {

		sleep(1);

		// envia sinal para threads aleatoriamente

		// int pthread_kill(pthread_t thread, int sig);
		ind=random()%N_THREADS;
		if((result=pthread_kill(th_vec[ind],SIGINT)==-1)) {
			strerror_r(result,err_msg,LEN);
			printf("Erro no envio de sinal (pthread_kill): %s\n",err_msg);
		}else 
			printf("Enviou sinal para %d\n",ind);
	}

	for(i=0;i<N_THREADS;i++) {
		if((result=pthread_join(th_vec[i], NULL)==-1)) {
			strerror_r(result,err_msg,LEN);
			printf("Erro em pthread_join thread %d: %s\n",i,err_msg); 
		} else {
			printf("Thread %lu joined\n",th_vec[i]);
		}
	}

	return 0;
}



